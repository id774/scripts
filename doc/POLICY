# Implementation Policies

This document defines implementation policies shared across Shell Scripts, Python, and Ruby,
followed by language-specific rules. The goal is to minimize redundancy while making the
design intent explicit and consistent for all contributors.

The **Common Policy** section defines rules that apply to *all* languages.
Each language section then specifies only what is unique to that language.

---

This section defines rules that apply uniformly to all languages.
Each language-specific section intentionally describes only deviations from
or additions to this common policy, in order to avoid redundancy.

## Common Policy (All Languages)

### Design Philosophy
- Prioritize clarity, portability, and explicit control over convenience.
- Favor predictable behavior and long-term maintainability.
- Avoid implicit behavior; make control flow, errors, and side effects explicit.

### Logging and Output
- Use unified log prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Informational messages go to standard output.
- Error messages always go to standard error.
- Log messages must be human-readable and suitable for cron execution.
- For automated emails (cron, admin jobs), use **filter-friendly tags**
  (e.g. `[cron]`, `[admin]`) in the subject line so recipients can easily
  classify, filter, or route messages.

### Error Handling and Exit Codes
- Detect command failures and unmet prerequisites early.
- Always log the reason and affected target when an error occurs.
- Exit code semantics must follow widely accepted UNIX/GNU/Linux conventions
  and remain consistent across the repository.

#### Exit Code Conventions
- **0: Success**
  The operation completed successfully.
  This includes cases where the program terminates after displaying help or
  usage information without encountering an error.

- **1: General failure**
  The default failure code.
  Use for invalid arguments, missing resources, processing errors, or any
  failure that does not require explicit classification.

- **126: Command or script exists but is not executable**
  Reserved by the shell. Do not redefine.

- **127: Command or script not found**
  Reserved by the shell. Do not redefine.

- **128 and above: Signal-related termination**
  Reserved by convention (128 + signal number). Do not use for application-defined errors.

> If finer-grained classification is truly required, `sysexits` codes (64â€“78)
> may be used, but must be explicitly documented in the script or program header.

### Control Flow Rules
- Use explicit termination (`exit`, `sys.exit`, `exit()`) **only for abnormal or forced termination**.
- Normal execution paths must return normally and propagate status explicitly.
- Do not rely on implicit termination or language-specific shortcuts
  (e.g. `set -e` in shell, bare `except` in Python).

### CLI Conventions
- All command-line tools must provide consistent options:
  - `-h`, `--help` to display usage information and exit with code `0`.
  - `-v`, `--version` to display version information and exit with code `0`.
- Help or version output represents a successful, user-requested termination.
- Invalid or unsupported options must result in usage output and exit with code `1`.

### Documentation and Versioning
- Every executable must contain a structured header with:
  `Description`, `Requirements`, `Usage`, `Options`, `Test Cases`, `Version History`
  (in this order).
- Documentation must be updated in sync with behavior changes.
- Do not increment version numbers multiple times on the same date.

### Comments and Language
- Comments must be written in **English** only.
- Comments must be imperative, concise, and action-oriented
  (e.g. `# Validate input`, `# Initialize environment`).

### Testing and Operation
- Assume cron execution by default; define `PATH` and required environment variables explicitly.
- Validation must include syntax checks and exit-code verification.
- In plugin-based systems, loaders must collect and propagate plugin return codes.

---

## Shell Script Implementation Policy

### Basic Principles
- Comply strictly with POSIX (`#!/bin/sh`).
- Avoid Bash-specific syntax and extensions.
- Do not use `local`.
- Modularize using small, single-purpose functions.
- Follow the structured header requirements defined in the Common Policy.

### Dependency and Environment Checks
- Validate required commands and environment variables at startup.
- For network operations, verify connectivity before execution.

### I/O and Side Effects
- Respect existing temporary file logic and directory structures.
- Avoid destructive overwrites; validate paths before modification.
- Align log writing and rotation with system log policy.

---

## Python Implementation Policy

### Supported Versions and Compatibility
- Target version: **Python 3.2+**, ideally **3.4+**.
- Avoid features that reduce backward compatibility unless guarded:
  - f-strings, `subprocess.run`, `subprocess.DEVNULL`
  - `async` / `await`, `yield from`, `asyncio`
  - Type hints, matrix operator `@`, unnecessary `nonlocal`
  - `pathlib`, `shutil.which`
- Use `find_pycompat.py` to verify compatibility.

### Program Structure
- Define `main() -> int` as the entry point.
- Terminate execution with `sys.exit(main())`.
- Use early returns to simplify control flow.

### Dependencies and I/O
- Depend only on the standard library.
- Implement manual PATH search if command lookup is required.
- Always use `encoding="utf-8"` for file operations.

### Testing
- Store tests in `test/` as `FILENAME_test.py`.
- Use only standard libraries for testing.
- Any compatibility issue detected by `find_pycompat.py` is a failure.

---

## Ruby Implementation Policy

### Supported Versions
- Minimum supported version: **Ruby 3.0 or later**.

### Program Structure
- Define `main` as the entry point.
- Finalize execution with `exit(main) if __FILE__ == $0`.
- Use early returns to simplify control flow.

### CLI Implementation
- Use `OptionParser` from the standard library to implement
  the common CLI conventions defined above.

### Dependencies and I/O
- Depend only on standard libraries.
- Use `Open3.capture3` for external command execution when stdout, stderr, or exit status must be inspected.
- `system` may be used only when command output is intentionally ignored and success or failure alone is sufficient.
- Always specify UTF-8 encoding for file operations.
- Validate file existence, type, and permissions before destructive operations.

### Testing
- Store tests in `test/` using RSpec as `FILENAME_test.rb`.
- Ensure all tests pass before release.
