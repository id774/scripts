# Implementation Policies

This document defines implementation policies for Shell Scripts, Python, and Ruby.
Design philosophy, logging style, and exit code semantics must be consistent across all languages.

Exit code semantics are defined in the Shell Script section and apply equally to Python and Ruby unless explicitly stated otherwise.

---

## Shell Script Implementation Policy

### Basic Principles
- Comply with POSIX (`#!/bin/sh`). Avoid Bash-specific syntax. Do not use `local`.
- Modularize using functions. Each function should be short and single-purpose.
- Preserve and update the header documentation, which must include:
  `Description`, `Requirements`, `Usage`, `Options`, `Test Cases`, and `Version History` (in this order).

### Logging and Output
- Use unified log prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Direct all error messages to standard error.
- For cron environments, follow the same log format.
- Email subject format:
  Use filter-friendly tags in the subject line (e.g. `[cron]`, `[admin]`)
  so that recipients can easily classify, filter, or route automated messages.

### Error Handling and Exit Codes
- Detect command failures and unmet prerequisites, and output clear, actionable log messages.
- Exit codes must follow widely accepted UNIX/GNU/Linux conventions and remain consistent across the repository.

#### Exit Code Conventions
- **0: Success**
  The operation completed successfully.
  This includes cases where the program terminates after displaying help or usage
  information without encountering an error.

- **1: General failure**
  The default failure code.
  Use for invalid arguments, missing resources, processing errors,
  or any failure that does not require explicit classification.

- **126: Command or script exists but is not executable**
  Reserved by the shell. Do not redefine.

- **127: Command or script not found**
  Reserved by the shell. Do not redefine.

- **128 and above: Signal-related termination**
  Reserved by convention (128 + signal number). Do not use for application-defined errors.

> If finer-grained classification is truly required, scripts may adopt `sysexits` codes (64â€“78).
> Any such usage must be explicitly documented in the script header.

#### Implementation Rules
- Use explicit `exit` only for abnormal or forced termination at the top level.
- For normal control flow, use `return` within functions and propagate the final status explicitly.
- Do not use `set -e`.
- Handle errors explicitly and robustly, performing early and strict checks to detect failures as soon as possible.

### Dependency and Environment Checks
- Validate required commands and environment variables at startup.
- For network operations, verify connectivity before execution.

### I/O and Side Effects
- Respect existing temporary file logic and directory structures.
- Avoid destructive overwrites. Validate paths before modification.
- Align log writing and rotation with system log policy.

### CLI and Usage
- Always implement `-h` to display usage and exit with code 0,
  as help output represents a successful, user-requested termination.
- Parse options in a POSIX-compliant manner.
- On invalid input or unsupported options, show usage and exit with code 1.

### Documentation and Version Control
- Update documentation (Usage, Options, Test Cases, Version History) in sync with code changes.
- Do not change version numbers multiple times on the same date.
  Keep the version static until completion.

### Comments and Language
- Use English comments only.
- Start comments with an action verb, concise and direct
  (e.g., `# Check files`, `# Initialize environment`).

### Testing and Operation
- Verify syntax and exit codes with a dedicated validation script using `-h` mode.
- Assume cron execution environment; define `PATH` and other environment variables explicitly.
- In plugin-based structures, the loader must collect and propagate plugin return codes.

---

## Python Implementation Policy

### Basic Principles
- Follow the same design philosophy as shell scripts: clarity, portability, and explicit control.
- Favor long-term compatibility and predictable behavior over syntactic convenience.

### Supported Versions and Compatibility
- Target version: **Python 3.2+**, ideally **3.4+**.
- Avoid features that reduce compatibility unless guarded by version checks:
  - f-strings, `subprocess.run`, `subprocess.DEVNULL`
  - `async` / `await`, `yield from`, `asyncio`
  - Type hints, matrix operator `@`, unnecessary `nonlocal`
  - `pathlib`, `shutil.which`
- Use `find_pycompat.py` to verify compatibility.

### Error Handling and Exit Codes
- Exit code semantics are **identical to the Shell Script policy**.
- Handle exceptions explicitly; never suppress them silently.
- Normalize errors to standard exit codes defined in the Shell Script policy.

### Program Structure
- Define `main() -> int` as the entry point.
- Terminate execution using `sys.exit(main())`.
- Use early returns to simplify control flow.

### Logging and Output
- Use standardized prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Send error messages to `sys.stderr`.
- Help output must exit with code 0.

### CLI and Usage
- Use only the standard library (e.g., `argparse`).
- On invalid arguments, show concise usage and exit with code 1.

### Dependencies and Environment
- Depend only on the standard library.
- Implement manual PATH search when command lookup is required.
- Always use `encoding="utf-8"` for file operations.

### I/O and Side Effects
- Validate file existence, type, and permissions before modification.
- Include affected paths and reasons in error messages.
- Follow the same temporary file conventions as shell scripts.

### Comments and Language
- Write comments in English, imperative, and concise.

### Testing and Verification
- Store tests in `test/` with names `FILENAME_test.py`.
- Use only standard libraries for testing.
- Any compatibility issue detected by `find_pycompat.py` is a failure.

---

## Ruby Implementation Policy

### Basic Principles
- Follow the same design philosophy as the Shell Script and Python policies.
- Prefer explicit, predictable constructs over dynamic or metaprogramming-heavy ones.
- Minimum supported version: **Ruby 3.0 or later**.

### Error Handling and Exit Codes
- Exit code semantics are **identical to the Shell Script policy**.
- Catch exceptions explicitly and log `[ERROR]` messages with cause and context.
- Never suppress exceptions silently.

### Program Structure
- Define `main` as the entry point.
- Finalize execution with `exit(main) if __FILE__ == $0`.
- Use early returns to simplify control flow.

### Logging and Output
- Use unified log prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Direct errors to `STDERR` and informational output to `STDOUT`.
- Help or version output must exit with code 0.

### CLI Design
- Use `OptionParser` from the standard library.
- Provide consistent options: `-h` / `--help`, `-v` / `--version`.
- On invalid arguments, show usage and exit with code 1.

### Dependencies and Environment
- Depend only on standard libraries.
- Use `Open3.capture3` or `system` for external command execution.
- Always specify UTF-8 encoding for file operations.

### I/O and Side Effects
- Verify file existence, type, and permissions before destructive operations.
- Include affected paths and reasons in error logs.
- Follow the same temporary file conventions as shell scripts.

### Comments and Language
- Write comments in English, imperative, and concise.

### Documentation and Version Control
- Maintain the same header structure as shell and Python scripts:
  `Description / Requirements / Usage / Options / Test Cases / Version History`.
- Update documentation in sync with behavior changes.
- Avoid multiple version increments within the same day.

### Testing and Verification
- Store tests in `test/` using RSpec with names `FILENAME_test.rb`.
- Ensure all tests pass before release.
