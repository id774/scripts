# Shell Script Implementation Policy

## Basic Principles
- Comply with POSIX (`#!/bin/sh`). Avoid Bash-specific syntax. Do not use `local`.
- Modularize using functions. Each function should be short and single-purpose.
- Preserve and update the header documentation, which must include:
  `Description`, `Requirements`, `Usage`, `Options`, `Test Cases`, and `Version History` (in this order).

## Logging and Output
- Use unified log prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Direct all error messages to standard error.
- For cron environments, follow the same log format.
- Email subject format: `[admin][cron][delivery] FILENAME`.

## Error Handling and Exit Codes
- Detect command failures and missing prerequisites, output clear log messages.
- Return code conventions:
  - 0: Success
  - 1: Command failure or resource missing
  - 2: Network unreachable
  - 3: Local prerequisite missing
  - 126: Command or script exists but is not executable
  - 127: Command or script not found
- Use explicit `exit` only for abnormal or forced termination.
  For normal flow, use `return` within functions and propagate the final status properly.
- Do not use `set -e`. Handle errors explicitly and robustly.
  Perform early and strict checks to detect issues as soon as possible.

## Dependency and Environment Checks
- Validate required commands and environment variables at startup.
- For network operations, verify connectivity before execution.
  If unreachable, return code 2.

## I/O and Side Effects
- Respect existing temporary file logic and directory structures.
- Avoid destructive overwrites. Validate paths before modification.
- Align log writing and rotation with system log policy.

## CLI and Usage
- Always implement `-h` to display usage and exit with code 0.
- Parse options in a POSIX-compliant manner. On invalid input, show usage and exit with code 1.

## Documentation and Version Control
- Update documentation (Usage, Options, Test Cases, Version History) in sync with code changes.
- Do not change version number on the same date.
  Keep the version static until completion.

## Comments and Language
- Use English comments only.
- Start comments with an action verb, concise and direct (e.g., `# Check files`, `# Initialize env`).

## Testing and Operation
- Verify syntax and exit codes with a dedicated validation script using `-h` mode.
- Assume cron execution environment; define PATH and other environment variables explicitly.
- In plugin-based structures, the loader must collect and propagate plugin return codes.


# Python Implementation Policy

## Basic Principles
- Follow the same design philosophy as shell scripts: clarity, portability, and explicit control.
- Maintain readability and backward compatibility over syntactic shortcuts.

## Supported Versions and Compatibility
- Target version: **Python 3.2+**, ideally **3.4+**. Ensure downward compatibility when feasible.
- Avoid features that reduce compatibility unless guarded by version checks:
  - f-strings, `subprocess.run`, `subprocess.DEVNULL`
  - `async` / `await`, `yield from`, `asyncio`
  - Type hints, matrix operator `@`, `nonlocal` usage beyond necessity
  - `pathlib`, `shutil.which`
- Use `find_pycompat.py` for compatibility verification.
  If any issue is detected outside `dummy.py`, exit with code 1.

## Exception Handling and Exit Codes
- Handle exceptions explicitly; never suppress them silently.
- Exit code conventions (aligned with shell policy):
  - 0: Success
  - 1: General error, invalid arguments, or missing prerequisites
  - 2: Network unreachable
  - 3: Local prerequisite missing
- Use `sys.exit(code)` **only for abnormal or forced termination**.
  Normal completion should return 0 from `main()` and call `sys.exit(main())`.
- Avoid implicit termination (like `set -e`); use explicit error checks and early validation.

## Logging and Output
- Standardize message prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Send errors to `sys.stderr`; informational output to `stdout`.
- Help output exits with code 0. Errors must include cause and affected target.

## CLI and Usage
- Include `if __name__ == "__main__":` guard.
- Use only the standard library (e.g., `argparse` in Python 3.2+).
- Invalid or missing arguments must trigger concise usage output and exit code 1.

## Dependencies and Environment
- Depend only on the standard library; external modules discouraged.
- Avoid `shutil.which`. Implement manual PATH search for command lookup.
- Always use `encoding="utf-8"` for file operations.
  Handle paths with `os` / `os.path`.

## I/O and Side Effects
- Validate files before modification (existence, type, permissions).
- Include filename and reason in all error logs.
- Manage temporary files and directories according to shell policy; never alter their conventions.

## Structure and Coding Style
- Entry point: `main() -> int`. Keep functions short, focused, and independent.
- Apply early returns to simplify control flow.
- Handle exceptions at consistent granularity and normalize to standard exit codes.
- Comments must be **English**, imperative, and brief (e.g., `# Validate input`, `# Read config`).
- Avoid global variables. Keep code deterministic and testable.

## Documentation
- Follow the same header order as shell scripts:
  `Description / Requirements / Usage / Options / Test Cases / Version History`.
- Update documentation whenever behavior changes.
  Do not modify version numbers multiple times per day.

## Testing and Verification
- Store test files in `test/` with names `FILENAME_test.py`.
  Use only standard libraries.
- Run `find_pycompat.py .` in CI or local environments for compatibility checks; any detection is a failure.
- Design functions with argument-driven logic to allow unit testing.

## Network and Process Execution
- Verify network connectivity before execution; if unreachable, return code 2.
- Define explicit timeouts and fixed retry counts.
- When invoking external commands, capture and inspect exit codes and streams.
  Log root causes and normalize to standard exit codes.


# Ruby Implementation Policy

## Basic Principles
- Follow the same design philosophy as the Shell and Python policies: clarity, portability, and maintainability.
- Prefer explicit and predictable structures rather than dynamic or metaprogramming-heavy ones.
- Clearly state the minimum supported version (e.g., **Ruby 3.0 or later**).
  Do not sacrifice code clarity or maintainability for backward compatibility.

## Error Handling and Exit Codes
- Catch exceptions explicitly and log `[ERROR]` messages with both cause and context.
- Never suppress exceptions silently.
- Exit code conventions (consistent with Shell and Python policies):
  - 0: Success
  - 1: General error, invalid arguments, or missing prerequisites
  - 2: Network unreachable
  - 3: Local prerequisite missing
- Use `exit(code)` **only for abnormal or forced termination**.
  For normal completion, let `main` return an integer and finalize with `exit(main) if __FILE__ == $0`.
- Perform early input and file validation to detect errors before execution.

## Logging and Output
- Use unified log prefixes: `[INFO]`, `[WARN]`, `[ERROR]`.
- Direct errors to `STDERR` (via `warn`) and informational messages to `STDOUT`.
- Help or version output should always exit with code 0.

## CLI Design
- Use `OptionParser` from the standard library for all command-line interfaces.
- Provide consistent options: `-h` / `--help`, `-v` / `--version`.
- On invalid arguments, show concise usage information and exit with code 1.

## Dependencies and Environment
- Depend only on standard libraries; avoid external gems unless absolutely necessary.
- Use modern Ruby APIs for external command execution (`Open3.capture3`, `system`) and for file traversal (`File.foreach`, `Dir.glob`, etc.).
- Always specify UTF-8 encoding for file operations to ensure consistent behavior.

## I/O and Side Effects
- Verify file existence, type, and permissions before performing destructive operations.
- Include affected file paths and reasons in all error logs for traceability.
- Follow the same conventions as the Shell policy for handling temporary files and directories.

## Structure and Coding Style
- Define `main()` as the entry point and finalize with `exit(main) if __FILE__ == $0`.
- Keep functions short, focused, and use **early returns** to simplify control flow.
- Write comments in **English**, imperative, and concise (e.g., `# Validate arguments`, `# Generate password`).
- Avoid global variables and unnecessary constant redefinitions. Keep code deterministic and side-effect free.

## Documentation
- Maintain the same header structure as in Shell and Python scripts:
  `Description / Requirements / Usage / Options / Test Cases / Version History`.
- Update documentation consistently with behavior changes.
- Avoid multiple version increments within the same day.

## Testing and Verification
- Store all test files in the `test/` directory and use **RSpec** for testing.
- Test filenames must follow the format `FILENAME_test.rb`.
- Use `describe` / `it` blocks with deterministic, side-effect-free tests.
- Ensure all tests pass with `bundle exec rspec` before release.

## External Commands and Network Operations
- Run external commands with `Open3.capture3` or `system`, checking both return codes and outputs explicitly.
- Verify network reachability before execution; if unreachable, return code 2.
- Set fixed timeouts and retry intervals to guarantee consistent and reproducible behavior.
